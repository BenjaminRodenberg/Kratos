//    |  /           |
//    ' /   __| _` | __|  _ \   __|
//    . \  |   (   | |   (   |\__ \.
//   _|\_\_|  \__,_|\__|\___/ ____/
//                   Multi-Physics
//
//  License:         BSD License
//                   Kratos default license: kratos/license.txt
//
//  Main authors:    Eduard GÃ³mez
//

/**
 *
 *                          WARNING! THIS FILE IS READ-ONLY
 *
 * This file has been auto-generated by the compressible navier stokes symbolic generator
 * located in the symbolic_generation directories of the FluidDynamicsApplication
 *
 * Any modifications to this file will be overwritten if and when that script is run again.
 *
 * In order to do any lasting changes, modify the template used by the script:
 * templates/compressible_navier_stokes_explicit_condition_template_2D2N.cpp
 * located in the symbolic_generation directories of the FluidDynamicsApplication.
 *
 * In order to change the formulation you will have to modify the script itself.
 */

// System includes


// External includes


// Project includes


// Application includes
#include "compressible_navier_stokes_explicit_condition.h"


namespace Kratos {

/**
 * Returns the integration method for computation of midpoint magnitudes.
 * Computation of RHS integration method is chosen in the symbolic generator.
 */
template<>
GeometryData::IntegrationMethod CompressibleNavierStokesExplicitCondition<2,2>::GetIntegrationMethod()
{
    return GeometryData::IntegrationMethod::GI_GAUSS_1;
}

template <>
void CompressibleNavierStokesExplicitCondition<2, 2>::EquationIdVector(
    EquationIdVectorType& rResult,
    const ProcessInfo& rCurrentProcessInfo) const
{
    KRATOS_TRY

    if (rResult.size() != DofSize) {
        rResult.resize(DofSize);
    }

    unsigned int local_index = 0;
    const auto& r_geometry = GetGeometry();
    const unsigned int den_pos = r_geometry[0].GetDofPosition(DENSITY);
    const unsigned int mom_pos = r_geometry[0].GetDofPosition(MOMENTUM);
    const unsigned int enr_pos = r_geometry[0].GetDofPosition(TOTAL_ENERGY);
    for (unsigned int i_node = 0; i_node < NumNodes; ++i_node) {
        rResult[local_index++] = r_geometry[i_node].GetDof(DENSITY, den_pos).EquationId();
        rResult[local_index++] = r_geometry[i_node].GetDof(MOMENTUM_X, mom_pos).EquationId();
        rResult[local_index++] = r_geometry[i_node].GetDof(MOMENTUM_Y, mom_pos + 1).EquationId();
        rResult[local_index++] = r_geometry[i_node].GetDof(TOTAL_ENERGY, enr_pos).EquationId();
    }

    KRATOS_CATCH("");
}

template <>
void CompressibleNavierStokesExplicitCondition<2, 2>::GetDofList(
    DofsVectorType& ConditionDofList,
    const ProcessInfo& rCurrentProcessInfo) const
{
    KRATOS_TRY

    if (ConditionDofList.size() != DofSize) {
        ConditionDofList.resize(DofSize);
    }

    unsigned int local_index = 0;
    const auto& r_geometry = GetGeometry();
    const unsigned int den_pos = r_geometry[0].GetDofPosition(DENSITY);
    const unsigned int mom_pos = r_geometry[0].GetDofPosition(MOMENTUM);
    const unsigned int enr_pos = r_geometry[0].GetDofPosition(TOTAL_ENERGY);
    for (unsigned int i_node = 0; i_node < NumNodes; ++i_node) {
        ConditionDofList[local_index++] = r_geometry[i_node].pGetDof(DENSITY, den_pos);
        ConditionDofList[local_index++] = r_geometry[i_node].pGetDof(MOMENTUM_X, mom_pos);
        ConditionDofList[local_index++] = r_geometry[i_node].pGetDof(MOMENTUM_Y, mom_pos + 1);
        ConditionDofList[local_index++] = r_geometry[i_node].pGetDof(TOTAL_ENERGY, enr_pos);
    }

    KRATOS_CATCH("");
}

template<>
BoundedVector<double, 8> CompressibleNavierStokesExplicitCondition<2,2>::CalculateRightHandSideInternal(
    const ProcessInfo& rCurrentProcessInfo)
{
    KRATOS_TRY

    BoundedVector<double, BlockSize*NumNodes> rRightHandSideBoundedVector = ZeroVector(BlockSize*NumNodes);

    const auto data = ConditionData(rCurrentProcessInfo);

    const double crRightHandSideBoundedVector0 = data.alpha_sc_nodes(0) + data.alpha_sc_nodes(1);
    const double crRightHandSideBoundedVector1 = data.U(0,1) + data.U(1,1);
    const double crRightHandSideBoundedVector2 = data.U(0,2) + data.U(1,2);
    const double crRightHandSideBoundedVector3 = -0.25*data.unit_normal(0)*(crRightHandSideBoundedVector0*data.gradients[0].density(0) + crRightHandSideBoundedVector1) - 0.25*data.unit_normal(1)*(crRightHandSideBoundedVector0*data.gradients[0].density(1) + crRightHandSideBoundedVector2);
    const double crRightHandSideBoundedVector4 = data.U(0,0) + data.U(1,0);
    const double crRightHandSideBoundedVector5 = 1.0/crRightHandSideBoundedVector4;
    const double crRightHandSideBoundedVector6 = 2.0*crRightHandSideBoundedVector5;
    const double crRightHandSideBoundedVector7 = data.mu + 0.5*data.mu_sc_nodes(0) + 0.5*data.mu_sc_nodes(1);
    const double crRightHandSideBoundedVector8 = crRightHandSideBoundedVector7*(-crRightHandSideBoundedVector1*data.gradients[0].density(1) - crRightHandSideBoundedVector2*data.gradients[0].density(0) + crRightHandSideBoundedVector4*data.gradients[0].momentum(0,1) + crRightHandSideBoundedVector4*data.gradients[0].momentum(1,0));
    const double crRightHandSideBoundedVector9 = crRightHandSideBoundedVector5*(-0.5*crRightHandSideBoundedVector1*crRightHandSideBoundedVector2 + crRightHandSideBoundedVector6*crRightHandSideBoundedVector8);
    const double crRightHandSideBoundedVector10 = pow(crRightHandSideBoundedVector1, 2);
    const double crRightHandSideBoundedVector11 = 0.5*crRightHandSideBoundedVector5;
    const double crRightHandSideBoundedVector12 = crRightHandSideBoundedVector1*data.gradients[0].density(0);
    const double crRightHandSideBoundedVector13 = crRightHandSideBoundedVector4*data.gradients[0].momentum(0,0);
    const double crRightHandSideBoundedVector14 = crRightHandSideBoundedVector12 - crRightHandSideBoundedVector13;
    const double crRightHandSideBoundedVector15 = pow(crRightHandSideBoundedVector4, -2);
    const double crRightHandSideBoundedVector16 = 4.0*crRightHandSideBoundedVector7;
    const double crRightHandSideBoundedVector17 = crRightHandSideBoundedVector15*crRightHandSideBoundedVector16;
    const double crRightHandSideBoundedVector18 = pow(crRightHandSideBoundedVector2, 2);
    const double crRightHandSideBoundedVector19 = 0.5*data.U(0,3) + 0.5*data.U(1,3);
    const double crRightHandSideBoundedVector20 = (crRightHandSideBoundedVector19 - crRightHandSideBoundedVector5*(0.25*crRightHandSideBoundedVector10 + 0.25*crRightHandSideBoundedVector18))*(data.gamma - 1);
    const double crRightHandSideBoundedVector21 = crRightHandSideBoundedVector2*data.gradients[0].density(1);
    const double crRightHandSideBoundedVector22 = crRightHandSideBoundedVector4*data.gradients[0].momentum(1,1);
    const double crRightHandSideBoundedVector23 = crRightHandSideBoundedVector21 - crRightHandSideBoundedVector22;
    const double crRightHandSideBoundedVector24 = 0.5*data.beta_sc_nodes(0);
    const double crRightHandSideBoundedVector25 = 0.5*data.beta_sc_nodes(1);
    const double crRightHandSideBoundedVector26 = 0.66666666666666663*data.mu;
    const double crRightHandSideBoundedVector27 = 0.33333333333333331*data.mu_sc_nodes(0);
    const double crRightHandSideBoundedVector28 = 0.33333333333333331*data.mu_sc_nodes(1);
    const double crRightHandSideBoundedVector29 = 2.0*crRightHandSideBoundedVector15;
    const double crRightHandSideBoundedVector30 = crRightHandSideBoundedVector20 - crRightHandSideBoundedVector29*(crRightHandSideBoundedVector14 + crRightHandSideBoundedVector23)*(-crRightHandSideBoundedVector24 - crRightHandSideBoundedVector25 + crRightHandSideBoundedVector26 + crRightHandSideBoundedVector27 + crRightHandSideBoundedVector28);
    const double crRightHandSideBoundedVector31 = 0.5*crRightHandSideBoundedVector9*data.unit_normal(1) - 0.5*data.unit_normal(0)*(crRightHandSideBoundedVector10*crRightHandSideBoundedVector11 + crRightHandSideBoundedVector14*crRightHandSideBoundedVector17 + crRightHandSideBoundedVector30);
    const double crRightHandSideBoundedVector32 = 0.5*crRightHandSideBoundedVector9*data.unit_normal(0) - 0.5*data.unit_normal(1)*(crRightHandSideBoundedVector11*crRightHandSideBoundedVector18 + crRightHandSideBoundedVector17*crRightHandSideBoundedVector23 + crRightHandSideBoundedVector30);
    const double crRightHandSideBoundedVector33 = crRightHandSideBoundedVector29*crRightHandSideBoundedVector8;
    const double crRightHandSideBoundedVector34 = 1.0*crRightHandSideBoundedVector19 + 1.0*crRightHandSideBoundedVector20;
    const double crRightHandSideBoundedVector35 = data.U(0,3) + data.U(1,3);
    const double crRightHandSideBoundedVector36 = crRightHandSideBoundedVector5*data.gradients[0].density(0);
    const double crRightHandSideBoundedVector37 = crRightHandSideBoundedVector6*(0.5*data.lamb_sc_nodes(0) + 0.5*data.lamb_sc_nodes(1) + data.lambda)/data.c_v;
    const double crRightHandSideBoundedVector38 = -crRightHandSideBoundedVector12 + crRightHandSideBoundedVector13;
    const double crRightHandSideBoundedVector39 = -crRightHandSideBoundedVector21 + crRightHandSideBoundedVector22;
    const double crRightHandSideBoundedVector40 = 2.0*(crRightHandSideBoundedVector38 + crRightHandSideBoundedVector39)*(crRightHandSideBoundedVector24 + crRightHandSideBoundedVector25 - crRightHandSideBoundedVector26 - crRightHandSideBoundedVector27 - crRightHandSideBoundedVector28);
    const double crRightHandSideBoundedVector41 = 1.0*crRightHandSideBoundedVector15;
    const double crRightHandSideBoundedVector42 = crRightHandSideBoundedVector5*data.gradients[0].density(1);
    const double crRightHandSideBoundedVector43 = crRightHandSideBoundedVector11*(data.unit_normal(0)*(-crRightHandSideBoundedVector1*crRightHandSideBoundedVector34 + crRightHandSideBoundedVector1*crRightHandSideBoundedVector41*(crRightHandSideBoundedVector16*crRightHandSideBoundedVector38 + crRightHandSideBoundedVector40) + crRightHandSideBoundedVector2*crRightHandSideBoundedVector33 + crRightHandSideBoundedVector37*(-crRightHandSideBoundedVector1*data.gradients[0].momentum(0,0) + crRightHandSideBoundedVector10*crRightHandSideBoundedVector36 + crRightHandSideBoundedVector18*crRightHandSideBoundedVector36 - crRightHandSideBoundedVector2*data.gradients[0].momentum(0,1) - crRightHandSideBoundedVector35*data.gradients[0].density(0) + crRightHandSideBoundedVector4*data.gradients[0].total_energy(0))) + data.unit_normal(1)*(crRightHandSideBoundedVector1*crRightHandSideBoundedVector33 - crRightHandSideBoundedVector2*crRightHandSideBoundedVector34 + crRightHandSideBoundedVector2*crRightHandSideBoundedVector41*(crRightHandSideBoundedVector16*crRightHandSideBoundedVector39 + crRightHandSideBoundedVector40) + crRightHandSideBoundedVector37*(-crRightHandSideBoundedVector1*data.gradients[0].momentum(1,0) + crRightHandSideBoundedVector10*crRightHandSideBoundedVector42 + crRightHandSideBoundedVector18*crRightHandSideBoundedVector42 - crRightHandSideBoundedVector2*data.gradients[0].momentum(1,1) - crRightHandSideBoundedVector35*data.gradients[0].density(1) + crRightHandSideBoundedVector4*data.gradients[0].total_energy(1))));
    rRightHandSideBoundedVector[0] = crRightHandSideBoundedVector3;
    rRightHandSideBoundedVector[1] = crRightHandSideBoundedVector31;
    rRightHandSideBoundedVector[2] = crRightHandSideBoundedVector32;
    rRightHandSideBoundedVector[3] = crRightHandSideBoundedVector43;
    rRightHandSideBoundedVector[4] = crRightHandSideBoundedVector3;
    rRightHandSideBoundedVector[5] = crRightHandSideBoundedVector31;
    rRightHandSideBoundedVector[6] = crRightHandSideBoundedVector32;
    rRightHandSideBoundedVector[7] = crRightHandSideBoundedVector43;


    rRightHandSideBoundedVector *= data.volume; // TODO: This only works for 1 gauss point

    return rRightHandSideBoundedVector;
    KRATOS_CATCH("")
}


template class CompressibleNavierStokesExplicitCondition<2,2>;
using CompressibleNavierStokesExplicitCondition2D2N = CompressibleNavierStokesExplicitCondition<2,2>;

}