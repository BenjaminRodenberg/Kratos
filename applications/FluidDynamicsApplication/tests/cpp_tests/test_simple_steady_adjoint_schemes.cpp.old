//    |  /           |
//    ' /   __| _` | __|  _ \   __|
//    . \  |   (   | |   (   |\__ `
//   _|\_\_|  \__,_|\__|\___/ ____/
//                   Multi-Physics
//
//  License:         BSD License
//                   Kratos default license: kratos/license.txt
//
//  Main authors:    Suneth Warnakulasuriya
//
//

// System includes

// External includes

// Project includes
#include "containers/model.h"
#include "includes/cfd_variables.h"
#include "includes/element.h"
#include "includes/model_part.h"
#include "testing/testing.h"

// Application includes
#include "custom_utilities/fluid_calculation_utilities.h"

namespace Kratos
{
namespace Testing
{
namespace TestUtilities
{
class TestPrimalElement : public Element
{
public:
    ///@name Type Definitions
    ///@{

    using BaseType = Element;

    using IndexType = Element::IndexType;

    using NodeType = Element::NodeType;

    using NodesArrayType = Element::NodesArrayType;

    using GeometryType = Element::GeometryType;

    using PropertiesType = Element::PropertiesType;

    using EquationIdVectorType = Element::EquationIdVectorType;

    using DofsVectorType = Element::DofsVectorType;

    constexpr IndexType TDim = 2;

    constexpr IndexType TNumNodes = 3;

    constexpr IndexType TBlockSize = TDim + 1;

    ///@}
    ///@name Life Cycle
    ///@{

    static Element::Pointer Create(NodeType::Pointer pNode1,
                                   NodeType::Pointer pNode2,
                                   NodeType::Pointer pNode3)
    {
        auto nodes = PointerVector<NodeType>{};
        nodes.push_back(pNode1);
        nodes.push_back(pNode2);
        nodes.push_back(pNode3);
        return Kratos::make_intrusive<TestPrimalElement>(nodes);
    }

    TestPrimalElement(const NodesArrayType& ThisNodes) : BaseType(0, ThisNodes)
    {
    }

    ///@}
    ///@name Operations
    ///@{

    void EquationIdVector(EquationIdVectorType& rResult,
                          const ProcessInfo& rCurrentProcessInfo) const override
    {
        if (rResult.size() != 9)
            rResult.resize(9, false);

        unsigned int local_index = 0;
        const auto& r_geometry = this->GetGeometry();

        for (unsigned int i = 0; i < 3; ++i) {
            rResult[local_index++] = r_geometry[i].GetDof(VELOCITY_X).EquationId();
            rResult[local_index++] = r_geometry[i].GetDof(VELOCITY_Y).EquationId();
            rResult[local_index++] = r_geometry[i].GetDof(PRESSURE).EquationId();
        }
    }

    void GetDofList(DofsVectorType& rElementalDofList,
                    const ProcessInfo& rCurrentProcessInfo) const override
    {
        if (rElementalDofList.size() != 9)
            rElementalDofList.resize(9);

        unsigned int local_index = 0;
        const auto& r_geometry = this->GetGeometry();

        for (unsigned int i = 0; i < 3; ++i) {
            rElementalDofList[local_index++] = r_geometry[i].pGetDof(VELOCITY_X);
            rElementalDofList[local_index++] = r_geometry[i].pGetDof(VELOCITY_Y);
            rElementalDofList[local_index++] = r_geometry[i].pGetDof(PRESSURE);
        }
    }

    void CalculateLocalSystem(MatrixType& rLeftHandSideMatrix,
                              VectorType& rRightHandSideVector,
                              const ProcessInfo& rCurrentProcessInfo) override
    {
        const unsigned int LocalSize = (TDim + 1) * TNumNodes;

        // Check sizes and initialize matrix
        if (rLeftHandSideMatrix.size1() != LocalSize)
            rLeftHandSideMatrix.resize(LocalSize, LocalSize, false);

        noalias(rLeftHandSideMatrix) = ZeroMatrix(LocalSize, LocalSize);

        // Calculate RHS
        this->CalculateRightHandSide(rRightHandSideVector, rCurrentProcessInfo);
    }

    void CalculateRightHandSide(VectorType& rRightHandSideVector,
                                const ProcessInfo& rCurrentProcessInfo) override
    {
        const unsigned int LocalSize = (TDim + 1) * TNumNodes;

        // Check sizes and initialize
        if (rRightHandSideVector.size() != LocalSize)
            rRightHandSideVector.resize(LocalSize, false);

        noalias(rRightHandSideVector) = ZeroVector(LocalSize);
    }

    void CalculateLocalVelocityContribution(MatrixType& rDampingMatrix,
                                            VectorType& rRightHandSideVector,
                                            const ProcessInfo& rCurrentProcessInfo) override
    {
        const unsigned int LocalSize = (TDim + 1) * TNumNodes;

        // Resize and set to zero the matrix
        // Note that we don't clean the RHS because it will already contain body force (and stabilization) contributions
        if (rDampingMatrix.size1() != LocalSize)
            rDampingMatrix.resize(LocalSize, LocalSize, false);

        noalias(rDampingMatrix) = ZeroMatrix(LocalSize, LocalSize);

        // calculate gauss point data
        double Area;
        array_1d<double, TNumNodes> N;
        BoundedMatrix<double, TNumNodes, TDim> DN_DX;
        GeometryUtils::CalculateGeometryData(this->GetGeometry(), DN_DX, N, Area);

        const BoundedMatrix<double, TNumNodes, TNumNodes> dNadNb =
            prod(DN_DX, trans(DN_DX));

        array_1d<double, 2> velocity;
        FluidCalculationUtilities::EvaluateInPoint(
            this->GetGeometry(), N, std::tie(velocity, VELOCITY));

        const BoundedVector<double, 3> velocity_dot_dndx = prod(DN_DX, velocity);

        for (IndexType a = 0; a < TNumNodes; ++a) {
            for (IndexType b = 0; b < TNumNodes; ++b) {
                for (IndexType i = 0; i < TDim; ++i) {
                    rDampingMatrix(a * TBlockSize + i, b * TBlockSize + i) +=
                        Area * dNadNb(a, b);
                }

                rDampingMatrix(a * TBlockSize + TDim, b * TBlockSize + TDim) +=
                    Area * N[a] * velocity_dot_dndx[b];
            }
        }
    }

    ///@}
};

void RunTestCase(Model& rModel)
{
    KRATOS_TRY

    auto& r_model_part = rModel.CreateModelPart("test", BufferSize);
    r_model_part.AddNodalSolutionStepVariable(VELOCITY);
    r_model_part.AddNodalSolutionStepVariable(PRESSURE);

    auto p_node_1 = r_model_part.CreateNewNode(1, 0.0, 0.0, 0.0);
    auto p_node_2 = r_model_part.CreateNewNode(2, 0.0, 1.0, 0.0);
    auto p_node_3 = r_model_part.CreateNewNode(3, 1.0, 1.0, 0.0);

    for (auto& r_node : r_model_part.Nodes()) {
        rNode.AddDof(VELOCITY_X);
        rNode.AddDof(VELOCITY_Y);
        rNode.AddDof(PRESSURE);
    }

    Properties::Pointer p_elem_prop = r_model_part.CreateNewProperties(0);

    using nid_list = std::vector<ModelPart::IndexType>;
    auto p_element = TestPrimalElement::Create(p_node_1, p_node_2, p_node_3);
    rModelPart.AddElement(p_element);

    r_model_part.CreateNewCondition("LineCondition2D2N", 1, nid_list{1, 2}, p_elem_prop);
    r_model_part.CreateNewCondition("LineCondition2D2N", 2, nid_list{2, 3}, p_elem_prop);
    r_model_part.CreateNewCondition("LineCondition2D2N", 3, nid_list{3, 1}, p_elem_prop);

    // apply boundary conditions
    // inlet is node 1
    p_node_1.Fix(VELOCITY_X) = 1.0;
    p_node_1.Fix(VELOCITY_Y) = 0.0;

    // outlet is node 3
    p_node_3.Fix(PRESSURE) = 10.0;



    KRATOS_CATCH("");
}
} // namespace TestUtilities

/**
 * Checks the body fitted drag computation utility.
 */
KRATOS_TEST_CASE_IN_SUITE(SimpleSteadyAdjointSchemes, FluidDynamicsApplicationFastSuite)
{
    // Create a test element inside a modelpart
    Model model;
    ModelPart& model_part = model.CreateModelPart("Main", 3);
    GenerateTestModelPart(model_part);
    Element::Pointer p_element = model_part.pGetElement(1);

    // Initialize the fluid element
    const auto& r_process_info = model_part.GetProcessInfo();
    p_element->Initialize(r_process_info);

    // Set the reaction values manually. Note that the body fitted drag utilities assume
    // that the REACTION has been already computed. Since this is assumed to be done by
    // the builder and solver, which is out of the scope of this test, we do it manually.
    model_part.GetNode(1).FastGetSolutionStepValue(REACTION_X) = 5.0;
    model_part.GetNode(1).FastGetSolutionStepValue(REACTION_Y) = 10.0;
    model_part.GetNode(2).FastGetSolutionStepValue(REACTION_X) = -20.0;
    model_part.GetNode(2).FastGetSolutionStepValue(REACTION_Y) = -40.0;

    // Call the body fitted drag utility
    DragUtilities drag_utilities;
    array_1d<double, 3> drag_force = drag_utilities.CalculateBodyFittedDrag(
        model_part.GetSubModelPart("DragModelPart"));

    // Check computed values
    KRATOS_CHECK_NEAR(drag_force[0], 15.0, 1e-6);
    KRATOS_CHECK_NEAR(drag_force[1], 30.0, 1e-6);
    KRATOS_CHECK_NEAR(drag_force[2], 0.0, 1e-6);
}

/**
 * Checks the embedded drag computation utility.
 */
KRATOS_TEST_CASE_IN_SUITE(ComputeEmbeddedDrag, FluidDynamicsApplicationFastSuite)
{
    bool is_embedded = true;

    // Create a test element inside a modelpart
    Model model;
    ModelPart& model_part = model.CreateModelPart("Main", 3);
    GenerateTestModelPart(model_part, is_embedded);

    // Initialize the fluid element
    const auto& r_process_info = model_part.GetProcessInfo();
    for (auto& r_elem : model_part.Elements()) {
        r_elem.Initialize(r_process_info);
    }

    // Call the embedded drag utility
    DragUtilities drag_utilities;
    array_1d<double, 3> drag_force = drag_utilities.CalculateEmbeddedDrag(model_part);

    // Check computed values
    KRATOS_CHECK_NEAR(drag_force[0], 6.72, 1e-2);
    KRATOS_CHECK_NEAR(drag_force[1], 0.8325, 1e-4);
    KRATOS_CHECK_NEAR(drag_force[2], 0.0, 1e-6);
}

/**
 * Checks the embedded drag center computation utility.
 */
KRATOS_TEST_CASE_IN_SUITE(ComputeEmbeddedDragCenter, FluidDynamicsApplicationFastSuite)
{
    bool is_embedded = true;

    // Create a test element inside a modelpart
    Model model;
    ModelPart& model_part = model.CreateModelPart("Main", 3);
    GenerateTestModelPart(model_part, is_embedded);

    // Initialize the fluid element
    const auto& r_process_info = model_part.GetProcessInfo();
    for (auto& r_elem : model_part.Elements()) {
        r_elem.Initialize(r_process_info);
    }

    // Call the embedded drag utility
    DragUtilities drag_utilities;
    array_1d<double, 3> drag_force_center =
        drag_utilities.CalculateEmbeddedDragCenter(model_part);

    // Check computed values
    KRATOS_CHECK_NEAR(drag_force_center[0], 0.25, 1e-2);
    KRATOS_CHECK_NEAR(drag_force_center[1], 0.5, 1e-4);
    KRATOS_CHECK_NEAR(drag_force_center[2], 0.0, 1e-6);
}

} // namespace Testing
} // namespace Kratos.
